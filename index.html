<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Virtual Tabletop</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      margin: 10px;
    }

    #sidebar {
      display: flex;
      flex-direction: column;
      margin-right: 20px;
    }

    #grid {
      border-collapse: collapse;
      position: relative;
    }

    #grid td {
      width: 40px;
      height: 40px;
      border: 1px solid #333;
      text-align: center;
      vertical-align: middle;
      font-size: 24px;
      user-select: none;
      position: relative;
    }

    #grid td.selected {
      background-color: rgba(0, 0, 255, 0.2);
      outline: 2px solid blue;
    }

    #selection-marquee {
      position: absolute;
      border: 1px dashed #00f;
      background: rgba(0, 0, 255, 0.1);
      display: none;
      pointer-events: none;
      z-index: 999;
    }

    #controls {
      min-width: 300px;
      display: flex;
      flex-direction: column;
    }

    #log {
      margin-top: 10px;
      background: #f4f4f4;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
      font-size: 14px;
      white-space: pre-wrap;
    }

    h2 {
      margin-top: 0;
    }

    #command-input {
      width: 100%;
      padding: 5px;
      box-sizing: border-box;
      margin-top: 10px;
    }

    #character-sheet-modal, #create-character-modal, #monster-sheet-modal {
      display: none; 
      position: fixed; 
      z-index: 999; 
      left: 0;
      top: 0;
      width: 100%; 
      height: 100%; 
      overflow: auto; 
      background-color: rgba(0,0,0,0.4);
    }

    .modal-content {
      background-color: #fff;
      margin: 5% auto; 
      padding: 20px;
      border: 1px solid #888;
      width: 300px;
      border-radius: 5px;
      position: relative;
    }

    .close-modal {
      float: right;
      cursor: pointer;
      font-weight: bold;
    }

    #character-details table, #monster-details table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 14px;
      border: 2px solid #000;
    }

    #character-details th, #character-details td, #monster-details th, #monster-details td {
      border: 1px solid #ccc;
      padding: 4px 6px;
    }

    #character-details th, #monster-details th {
      background: #ddd;
    }

    #dice-roller {
      margin-bottom: 10px;
    }

    #dice-expression {
      width: 120px;
    }

    #assign-owner-field {
      display: none; 
    }

    .context-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #aaa;
      z-index: 1000;
      display: none;
      font-size: 14px;
    }

    .context-menu ul {
      list-style: none;
      margin: 0;
      padding: 5px 0;
    }

    .context-menu ul li {
      padding: 5px 10px;
      cursor: pointer;
    }

    .context-menu ul li:hover {
      background: #eee;
    }

    #character-list, #monster-list {
      margin-top: 20px;
      background: #fafafa;
      padding: 10px;
      border: 1px solid #ccc;
      max-height: 200px;
      overflow-y: auto;
    }

    #character-list h3, #monster-list h3 {
      margin-top: 0;
    }

    .character-list-item, .monster-list-item {
      margin-bottom: 5px;
      display: flex;
      align-items: center;
    }

    .character-list-item button, .monster-list-item button {
      margin-left: 10px;
    }

    .drag-icon {
      margin-right: 10px;
      cursor: grab;
    }

    .drag-icon[draggable="false"] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #monster-filter {
      margin-bottom: 10px;
      width: 100%;
    }

    #create-character-form label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
    }

    #create-character-form input, #create-character-form select {
      margin-top: 4px;
      width: 100%;
      box-sizing: border-box;
    }

    #attack-creation-section {
      margin-top: 10px;
      background: #f0f0f0;
      padding: 5px;
      border: 1px solid #ccc;
    }

    #attack-creation-section h4 {
      margin: 5px 0;
    }

    .attack-input-row {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .attack-input-row select, .attack-input-row input {
      margin-right: 5px;
    }
  </style>
</head>
<body>

  <div id="sidebar">
    <h2>Current User</h2>
    <select id="user-select">
      <option value="DM">DM</option>
      <option value="Player1">Player1</option>
      <option value="Player2">Player2</option>
    </select>

    <h2>Board</h2>
    <div style="position: relative;">
      <table id="grid"></table>
      <div id="selection-marquee"></div>
    </div>
  </div>

  <div id="controls">
    <h2>Character Management</h2>
    <button id="create-character-btn">Create Character</button>

    <h2>Dice Roller</h2>
    <div id="dice-roller">
      <input type="text" id="dice-expression" placeholder="e.g. 2d6+3">
      <button id="roll-expression">Roll</button>
    </div>
    <div>
      <button class="dice-button" data-sides="4">d4</button>
      <button class="dice-button" data-sides="6">d6</button>
      <button class="dice-button" data-sides="8">d8</button>
      <button class="dice-button" data-sides="10">d10</button>
      <button class="dice-button" data-sides="12">d12</button>
      <button class="dice-button" data-sides="20">d20</button>
    </div>

    <div id="log"></div>
    <input type="text" id="command-input" placeholder="Type a command or chat message..." />

    <div id="character-list">
      <h3>All Characters</h3>
      <div id="character-list-entries"></div>
    </div>

    <div id="monster-list" style="display:none;">
      <h3>Monsters</h3>
      <select id="monster-filter">
        <option value="">-- Select Environment --</option>
        <option value="Desert">Desert</option>
        <option value="Grasslands">Grasslands</option>
        <option value="Riverlands">Riverlands</option>
      </select>
      <div id="monster-list-entries"></div>
    </div>
  </div>

  <!-- Character Sheet Modal -->
  <div id="character-sheet-modal">
    <div class="modal-content">
      <span class="close-modal" id="close-sheet">&times;</span>
      <h3 id="character-name"></h3>
      <div id="character-details"></div>
      <div id="character-attacks"></div>
    </div>
  </div>

  <!-- Monster Sheet Modal -->
  <div id="monster-sheet-modal">
    <div class="modal-content">
      <span class="close-modal" id="close-monster-sheet">&times;</span>
      <h3 id="monster-name"></h3>
      <div id="monster-details"></div>
      <div id="monster-attacks"></div>
    </div>
  </div>

  <!-- Create Character Modal -->
  <div id="create-character-modal">
    <div class="modal-content">
      <span class="close-modal" id="close-create-character">&times;</span>
      <h3>Create Character</h3>
      <form id="create-character-form">
        <label>Name: <input type="text" name="name" required></label>
        <label>Class: <input type="text" name="class" required></label>
        <label>Level: <input type="number" name="level" value="1" min="1" required></label>
        <label>HP: <input type="number" name="HP" value="10" required></label>
        <label>AC: <input type="number" name="AC" value="10" required></label>
        <label>STR: <input type="number" name="STR" value="10" required></label>
        <label>DEX: <input type="number" name="DEX" value="10" required></label>
        <label>CON: <input type="number" name="CON" value="10" required></label>
        <label>INT: <input type="number" name="INT" value="10" required></label>
        <label>WIS: <input type="number" name="WIS" value="10" required></label>
        <label>CHA: <input type="number" name="CHA" value="10" required></label>

        <div id="attack-creation-section">
          <h4>Add Attacks</h4>
          <div id="attack-creation-list"></div>
          <button type="button" id="add-attack-btn">Add Attack</button>
        </div>

        <div id="assign-owner-field">
          <label>Assign to:
            <select name="owner">
              <option value="DM">DM</option>
              <option value="Player1">Player1</option>
              <option value="Player2">Player2</option>
            </select>
          </label>
        </div>

        <button type="submit">Create</button>
      </form>
    </div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="context-menu">
    <ul>
      <li id="context-delete">Delete</li>
    </ul>
  </div>

  <script>
    const rows = 8;
    const cols = 8;
    const users = ["DM","Player1","Player2"];
    let currentUser = "DM";

    const weapons = [
      {id:1, name:"Short Sword", damageDice:"1d6", stat:"STR", baseMod:2},
      {id:2, name:"Long Bow", damageDice:"1d8", stat:"DEX", baseMod:1},
      {id:3, name:"Dagger", damageDice:"1d4", stat:"DEX", baseMod:3}
    ];

    let characters = [];
    let nextCharacterId = 1;

    let monsters = [
      {id:1, name:"Sand Wurm", HP:50, AC:14, STR:18, DEX:8, CON:16, INT:5, WIS:10, CHA:5, habitats:["Desert"], attacks:[{weaponId:1, customMod:0}]},
      {id:2, name:"Cactus Crawler", HP:20, AC:12, STR:12, DEX:14, CON:10, INT:2, WIS:8, CHA:6, habitats:["Desert","Grasslands"], attacks:[]},
      {id:3, name:"River Drake", HP:30, AC:15, STR:14, DEX:12, CON:13, INT:6, WIS:10, CHA:8, habitats:["Riverlands"], attacks:[]},
      {id:4, name:"Plains Stalker", HP:25, AC:13, STR:13, DEX:16, CON:11, INT:4, WIS:10, CHA:6, habitats:["Grasslands"], attacks:[]}
    ];

    let entityTokens = {};
    let messages = [];

    function isDM() {
      return currentUser === "DM";
    }

    // Build the grid
    const gridEl = document.getElementById('grid');
    for (let r = 0; r < rows; r++) {
      const rowEl = document.createElement('tr');
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement('td');
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.addEventListener('dragover', (ev) => ev.preventDefault());
        cell.addEventListener('drop', (ev) => {
          ev.preventDefault();
          if (draggedCharId !== null) {
            placeCharacterOnBoard(draggedCharId, r, c);
          }
          if (draggedMonsterId !== null) {
            placeMonsterOnBoard(draggedMonsterId, r, c);
          }
        });
        rowEl.appendChild(cell);
      }
      gridEl.appendChild(rowEl);
    }
    const marqueeEl = document.getElementById('selection-marquee');
    // Selection and marquee logic
    let selectedEntities = [];
    let isDraggingTokens = false;
    let dragStartPos = {x:0,y:0};
    let originalPositions = [];

    let isMarqueeSelecting = false;
    let marqueeStart = {x:0, y:0};
    let marqueeRect = {x:0, y:0, w:0, h:0};

    gridEl.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // Left-click only

      const rect = gridEl.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const cellWidth = 40;
      const cellHeight = 40;

      const c = Math.floor(x / cellWidth);
      const r = Math.floor(y / cellHeight);

      if (r < 0 || r >= rows || c < 0 || c >= cols) return; // Click outside grid

      const key = `${r},${c}`;
      const entity = entityTokens[key];
      const ctrlPressed = e.ctrlKey;

      if (entity) {
        if (ctrlPressed) {
          // Toggle selection
          if (isEntitySelected(entity)) {
            selectedEntities = selectedEntities.filter(se => !(se.type === entity.type && se.id === entity.id));
          } else {
            selectedEntities.push({ type: entity.type, id: entity.id });
          }
        } else {
          if (isEntitySelected(entity)) {
            // Already selected, do nothing
          } else {
            selectedEntities = [{ type: entity.type, id: entity.id }];
          }
        }

        if (selectedEntities.length > 0 && selectedEntities.every(canControlEntity)) {
          isDraggingTokens = true;
          dragStartPos = { x: e.clientX, y: e.clientY };
          originalPositions = selectedEntities.map(ent => {
            let pos = getEntityPosition(ent.type, ent.id);
            return { ...ent, row: pos.row, col: pos.col };
          });
        }
      } else {
        if (!ctrlPressed) {
          selectedEntities = [];
        }
        isMarqueeSelecting = true;
        marqueeStart = { x: x, y: y };
        marqueeEl.style.display = 'block';
        marqueeEl.style.left = `${marqueeStart.x}px`;
        marqueeEl.style.top = `${marqueeStart.y}px`;
        marqueeEl.style.width = '0px';
        marqueeEl.style.height = '0px';
      }

      updateSelectionStyles();
    });

    document.addEventListener('mousemove', (e) => {
      if (isDraggingTokens && selectedEntities.length > 0) {
        const dx = e.clientX - dragStartPos.x;
        const dy = e.clientY - dragStartPos.y;
        const cellWidth = 40;
        const cellHeight = 40;
        const rowOffset = Math.round(dy / cellHeight);
        const colOffset = Math.round(dx / cellWidth);
        highlightDragPositions(rowOffset, colOffset);
      }

      if (isMarqueeSelecting) {
        const rect = gridEl.getBoundingClientRect();
        let currentX = e.clientX - rect.left;
        let currentY = e.clientY - rect.top;

        // Constrain within grid
        currentX = Math.max(0, Math.min(currentX, cols * 40));
        currentY = Math.max(0, Math.min(currentY, rows * 40));

        const x1 = Math.min(currentX, marqueeStart.x);
        const y1 = Math.min(currentY, marqueeStart.y);
        const x2 = Math.max(currentX, marqueeStart.x);
        const y2 = Math.max(currentY, marqueeStart.y);

        marqueeRect = {
          x: x1,
          y: y1,
          w: x2 - x1,
          h: y2 - y1
        };

        marqueeEl.style.left = `${x1}px`;
        marqueeEl.style.top = `${y1}px`;
        marqueeEl.style.width = `${marqueeRect.w}px`;
        marqueeEl.style.height = `${marqueeRect.h}px`;
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (isDraggingTokens) {
        isDraggingTokens = false;
        const dx = e.clientX - dragStartPos.x;
        const dy = e.clientY - dragStartPos.y;
        const cellWidth = 40;
        const cellHeight = 40;
        const rowOffset = Math.round(dy / cellHeight);
        const colOffset = Math.round(dx / cellWidth);

        if (rowOffset !== 0 || colOffset !== 0) {
          moveSelectedEntities(rowOffset, colOffset);
        }
        clearDragHighlights();
      }

      if (isMarqueeSelecting) {
        isMarqueeSelecting = false;
        marqueeEl.style.display = 'none';
        selectedEntities = getEntitiesInMarquee();
        updateSelectionStyles();
      }
    });

    // Context menu for deletion
    const contextMenu = document.getElementById('context-menu');
    const contextDelete = document.getElementById('context-delete');
    let contextMenuVisible = false;

    document.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const cell = e.target.closest('td');
      if (!cell) {
        hideContextMenu();
        return;
      }

      const r = parseInt(cell.dataset.row,10);
      const c = parseInt(cell.dataset.col,10);
      const entity = entityTokens[`${r},${c}`];

      if (entity && isEntitySelected(entity) && canControlEntity(entity)) {
        showContextMenu(e.pageX, e.pageY);
      } else {
        hideContextMenu();
      }
    });

    contextDelete.addEventListener('click', () => {
      deleteSelectedEntities();
      hideContextMenu();
    });

    document.addEventListener('click', (e) => {
      if (contextMenuVisible && !contextMenu.contains(e.target)) {
        hideContextMenu();
      }
    });

    function showContextMenu(x, y) {
      contextMenu.style.display = 'block';
      contextMenu.style.left = `${x}px`;
      contextMenu.style.top = `${y}px`;
      contextMenuVisible = true;
    }

    function hideContextMenu() {
      contextMenu.style.display = 'none';
      contextMenuVisible = false;
    }

    // Dice and chat
    const logEl = document.getElementById('log');
    const commandInput = document.getElementById('command-input');

    function addMessage(msgObj) {
      messages.push(msgObj);
      renderLog();
    }

    function renderLog() {
      let displayText = '';
      for (let msg of messages) {
        if (!msg.private) {
          displayText += `${msg.sender}: ${msg.text}\n`;
        } else {
          if (isDM() || (msg.recipients && msg.recipients.includes(currentUser))) {
            let recipientsStr = msg.recipients.join(', ');
            displayText += `${msg.sender} -> ${recipientsStr}: ${msg.text}\n`;
          }
        }
      }
      logEl.textContent = displayText;
      logEl.scrollTop = logEl.scrollHeight;
    }

    commandInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const command = commandInput.value.trim();
        commandInput.value = '';

        if (!command) return;

        if (command.toLowerCase().startsWith('/roll')) {
          const parts = command.split(/\s+/);
          let recipients = null; 
          let diceExprIndex = 1;

          if (parts.length > 2 && parts[1].toLowerCase() === '/w') {
            recipients = [];
            let i = 2;
            for (; i < parts.length; i++) {
              if (parts[i].match(/d/)) {
                diceExprIndex = i;
                break;
              } else {
                if (users.includes(parts[i])) {
                  recipients.push(parts[i]);
                }
              }
            }
          }

          const diceExpr = parts.slice(diceExprIndex).join('');
          if (diceExpr) {
            const result = rollCombinedDiceExpression(diceExpr);
            if (recipients && recipients.length > 0) {
              if (!recipients.includes("DM")) recipients.push("DM");
              if (!recipients.includes(currentUser)) recipients.push(currentUser);
              addMessage({text:result, sender:currentUser, private:true, recipients:recipients});
            } else {
              addMessage({text:result, sender:currentUser, private:false});
            }
          } else {
            addMessage({text:"No dice expression provided.", sender:"System", private:false});
          }

        } else if (command.startsWith('/')) {
          addMessage({text:`Unrecognized command: ${command}`, sender:"System", private:false});
        } else {
          addMessage({text:command, sender:currentUser, private:false});
        }
      }
    });

    function rollSingleDice(sides) {
      return Math.floor(Math.random() * sides) + 1;
    }

    function rollCombinedDiceExpression(expression) {
      const originalExpr = expression;
      expression = expression.trim().replace(/\s+/g,'');
      const regex = /([+\-])?(\d*d\d+|\d+)/gi;
      let total = 0;
      let detailParts = [];
      let match;

      while((match = regex.exec(expression)) !== null) {
        let sign = match[1] || '+';
        let token = match[2];

        let signFactor = (sign === '-') ? -1 : 1;

        if (token.includes('d')) {
          let [diceCountStr, sidesStr] = token.split('d');
          let diceCount = parseInt(diceCountStr || '1', 10);
          let sides = parseInt(sidesStr,10);

          let rolls = [];
          for (let i=0; i<diceCount; i++){
            let result = rollSingleDice(sides);
            rolls.push(result);
          }

          let sumRolls = rolls.reduce((a,b)=>a+b,0);
          total += sumRolls * signFactor;
          detailParts.push(`${sign}${diceCount}d${sides} [${rolls.join(',')}]`);
        } else {
          let num = parseInt(token,10);
          total += num * signFactor;
          detailParts.push(`${sign}${num}`);
        }
      }

      let detailStr = detailParts.join('');
      detailStr = detailStr.replace(/^\+/,''); 
      return `Rolled ${originalExpr}: ${detailStr} = ${total}`;
    }

    document.querySelectorAll('.dice-button').forEach(btn => {
      btn.addEventListener('click', () => {
        const sides = parseInt(btn.dataset.sides, 10);
        const result = rollSingleDice(sides);
        addMessage({text:`Rolled d${sides}: ${result}`, sender:currentUser, private:false});
      });
    });

    document.getElementById('roll-expression').addEventListener('click', () => {
      const expr = document.getElementById('dice-expression').value;
      if (expr) {
        const result = rollCombinedDiceExpression(expr);
        addMessage({text:result, sender:currentUser, private:false});
      }
    });

    // Helper functions
    function canControlEntity(entity) {
      if (entity.type === "character") {
        let ch = getCharacterById(entity.id);
        return ch && (isDM() || ch.owner === currentUser);
      } else {
        return isDM(); // only DM controls monsters
      }
    }

    function getCharacterById(id) {
      return characters.find(ch => ch.id === id);
    }

    function getMonsterById(id) {
      return monsters.find(m => m.id === id);
    }

    function getEntityPosition(type, id) {
      for (const key in entityTokens) {
        const et = entityTokens[key];
        if (et.type === type && et.id === id) {
          const [r,c] = key.split(',').map(Number);
          return {row:r, col:c};
        }
      }
      return null;
    }

    function isEntitySelected(ent) {
      return selectedEntities.some(e => e.type === ent.type && e.id === ent.id);
    }

    function updateSelectionStyles() {
      const cells = gridEl.querySelectorAll('td');
      cells.forEach(cell => cell.classList.remove('selected'));

      for (let ent of selectedEntities) {
        const pos = getEntityPosition(ent.type, ent.id);
        if (pos) {
          const cell = gridEl.querySelector(`td[data-row='${pos.row}'][data-col='${pos.col}']`);
          if (cell) cell.classList.add('selected');
        }
      }
    }

    function moveSelectedEntities(rowOffset, colOffset) {
      let newPositions = [];
      for (let i=0; i<selectedEntities.length; i++) {
        const ent = selectedEntities[i];
        const oldPos = originalPositions[i];
        const newRow = oldPos.row + rowOffset;
        const newCol = oldPos.col + colOffset;
        if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols) {
          return;
        }
        const destKey = `${newRow},${newCol}`;
        if (entityTokens[destKey] && !selectedEntities.some(se => {
          const p = getEntityPosition(se.type,se.id);
          return p && p.row === newRow && p.col === newCol;
        })) {
          return;
        }
        newPositions.push({...ent, row:newRow, col:newCol});
      }

      for (const ent of selectedEntities) {
        const pos = getEntityPosition(ent.type, ent.id);
        if (pos) delete entityTokens[`${pos.row},${pos.col}`];
      }

      for (const np of newPositions) {
        entityTokens[`${np.row},${np.col}`] = {type:np.type, id:np.id};
      }

      redrawBoard();
    }

    function redrawBoard() {
      const cells = gridEl.querySelectorAll('td');
      cells.forEach(cell => cell.textContent = '');
      for (const key in entityTokens) {
        const et = entityTokens[key];
        const [r,c] = key.split(',').map(Number);
        const cell = gridEl.querySelector(`td[data-row='${r}'][data-col='${c}']`);
        if (et.type === "character") cell.textContent = '@';
        else cell.textContent = 'M';
      }
      updateSelectionStyles();
    }

    function highlightDragPositions(rowOffset, colOffset) {
      clearDragHighlights();
      for (let i=0; i<selectedEntities.length; i++) {
        const ent = selectedEntities[i];
        const oldPos = originalPositions[i];
        const nr = oldPos.row + rowOffset;
        const nc = oldPos.col + colOffset;
        if (nr >=0 && nr < rows && nc >=0 && nc < cols) {
          const cell = gridEl.querySelector(`td[data-row='${nr}'][data-col='${nc}']`);
          if (cell) cell.style.outline = '2px dashed green';
        }
      }
    }

    function clearDragHighlights() {
      const cells = gridEl.querySelectorAll('td');
      cells.forEach(cell => cell.style.outline = '');
    }

    function deleteSelectedEntities() {
      for (let ent of selectedEntities) {
        const pos = getEntityPosition(ent.type, ent.id);
        if (pos) delete entityTokens[`${pos.row},${pos.col}`];
        if (ent.type === "character") {
          const ch = getCharacterById(ent.id);
          if (ch) ch.placed = false;
        }
        // Monsters don't have a placed flag in this example, but could be added
      }
      selectedEntities = [];
      redrawBoard();
      renderCharacterList();
      renderMonsterList();
    }

    function getEntitiesInMarquee() {
      console.log('Marquee Rect:', marqueeRect);
      const cellWidth = 40;
      const cellHeight = 40;
      let selected = [];

      for (const key in entityTokens) {
        const [r, c] = key.split(',').map(Number);
        const cellX = c * cellWidth;
        const cellY = r * cellHeight;

        const isSelected =
          cellX < marqueeRect.x + marqueeRect.w &&
          cellX + cellWidth > marqueeRect.x &&
          cellY < marqueeRect.y + marqueeRect.h &&
          cellY + cellHeight > marqueeRect.y;

        if (isSelected) {
          console.log(`Selected entity at row ${r}, col ${c}:`, entityTokens[key]);
          selected.push({ type: entityTokens[key].type, id: entityTokens[key].id });
        }
      }
      return selected;
    }

    // Attacks
    function getPossibleTargets(attackerType, attackerData) {
      let targets = characters.map(ch => ({type:"character",id:ch.id,name:ch.name, placed:ch.placed}));
      for (const key in entityTokens) {
        const et = entityTokens[key];
        if (et.type === "character") {
          // already included as all characters known
        } else {
          const m = getMonsterById(et.id);
          if (m && !targets.find(t => t.type === "monster" && t.id === m.id)) {
            targets.push({type:"monster",id:m.id,name:m.name,placed:true});
          }
        }
      }
      // Remove self
      targets = targets.filter(t => t.name !== attackerData.name);
      return targets;
    }

    function rollDamageDice(diceExp, statMod, baseMod, customMod) {
      const match = diceExp.match(/(\d+)d(\d+)/);
      if (!match) return { total: 0, details: "Invalid dice expression." };
      let diceCount = parseInt(match[1],10);
      let diceSides = parseInt(match[2],10);
      let rolls = [];
      for (let i=0; i<diceCount; i++){
        rolls.push(rollSingleDice(diceSides));
      }
      let sum = rolls.reduce((a,b)=>a+b,0) + statMod + baseMod + customMod;
      return {total:sum, details:`(${rolls.join(',')})+Stat(${statMod})+Wep(${baseMod})+Custom(${customMod})`};
    }

    function performAttack(entityData, type, attackEntry, weapon) {
      let possibleTargets = getPossibleTargets(type, entityData);
      if (possibleTargets.length === 0) {
        addMessage({sender:"System",text:"No targets available.", private:false});
        return;
      }

      let targetName = prompt("Choose a target (Type exact name):\n" + possibleTargets.map(pt => pt.name).join('\n'));
      if (!targetName) return;
      let target = possibleTargets.find(pt => pt.name === targetName);
      if (!target) {
        addMessage({sender:"System",text:"Invalid target selected.", private:false});
        return;
      }

      let statVal = entityData[weapon.stat];
      let statMod = Math.floor((statVal - 10)/2);
      let roll = rollSingleDice(20);
      let totalAttack = roll + statMod + weapon.baseMod + attackEntry.customMod;

      let damage = rollDamageDice(weapon.damageDice, statMod, weapon.baseMod, attackEntry.customMod);

      addMessage({
        sender: entityData.name,
        text: `Attacks ${target.name} with ${weapon.name}!\nAttack Roll: d20(${roll})+Stat(${statMod})+Wep(${weapon.baseMod})+Custom(${attackEntry.customMod}) = ${totalAttack}\nDamage: ${damage.details} = ${damage.total}`,
        private: false
      });
    }

    // Rendering sheets
    const sheetModal = document.getElementById('character-sheet-modal');
    const monsterSheetModal = document.getElementById('monster-sheet-modal');
    const closeSheet = document.getElementById('close-sheet');
    const closeMonsterSheet = document.getElementById('close-monster-sheet');
    const charNameEl = document.getElementById('character-name');
    const charDetailsEl = document.getElementById('character-details');
    const charAttacksEl = document.getElementById('character-attacks');

    const monsterNameEl = document.getElementById('monster-name');
    const monsterDetailsEl = document.getElementById('monster-details');
    const monsterAttacksEl = document.getElementById('monster-attacks');

    closeSheet.onclick = () => sheetModal.style.display = "none";
    closeMonsterSheet.onclick = () => monsterSheetModal.style.display = "none";

    function renderAttacksSection(entityData, type, containerEl) {
      containerEl.innerHTML = `<h4>Attacks</h4>`;
      if (!entityData.attacks || entityData.attacks.length === 0) {
        containerEl.innerHTML += `<p>No attacks.</p>`;
        return;
      }

      for (let att of entityData.attacks) {
        const w = weapons.find(wep => wep.id === att.weaponId);
        if (!w) continue;
        const attackDiv = document.createElement('div');
        attackDiv.textContent = `${w.name} (Custom Mod: ${att.customMod}) `;
        const attackBtn = document.createElement('button');
        attackBtn.textContent = "Attack!";
        attackBtn.addEventListener('click', () => {
          performAttack(entityData, type, att, w);
        });
        attackDiv.appendChild(attackBtn);
        containerEl.appendChild(attackDiv);
      }
    }

    function openCharacterSheet(ch) {
      charNameEl.textContent = ch.name;
      charDetailsEl.innerHTML = `
        <table>
          <tr><th>Class</th><td>${ch.class}</td></tr>
          <tr><th>Level</th><td>${ch.level}</td></tr>
          <tr><th>HP</th><td>${ch.HP}</td></tr>
          <tr><th>AC</th><td>${ch.AC}</td></tr>
          <tr><th>STR</th><td>${ch.STR}</td></tr>
          <tr><th>DEX</th><td>${ch.DEX}</td></tr>
          <tr><th>CON</th><td>${ch.CON}</td></tr>
          <tr><th>INT</th><td>${ch.INT}</td></tr>
          <tr><th>WIS</th><td>${ch.WIS}</td></tr>
          <tr><th>CHA</th><td>${ch.CHA}</td></tr>
        </table>
      `;
      renderAttacksSection(ch, "character", charAttacksEl);
      sheetModal.style.display = "block";
    }

    function openMonsterSheet(m) {
      monsterNameEl.textContent = m.name;
      monsterDetailsEl.innerHTML = `
        <table>
          <tr><th>HP</th><td>${m.HP}</td></tr>
          <tr><th>AC</th><td>${m.AC}</td></tr>
          <tr><th>STR</th><td>${m.STR}</td></tr>
          <tr><th>DEX</th><td>${m.DEX}</td></tr>
          <tr><th>CON</th><td>${m.CON}</td></tr>
          <tr><th>INT</th><td>${m.INT}</td></tr>
          <tr><th>WIS</th><td>${m.WIS}</td></tr>
          <tr><th>CHA</th><td>${m.CHA}</td></tr>
          <tr><th>Habitats</th><td>${m.habitats.join(', ')}</td></tr>
        </table>
      `;
      renderAttacksSection(m, "monster", monsterAttacksEl);
      monsterSheetModal.style.display = "block";
    }

    // Create Character Modal
    const createCharacterModal = document.getElementById('create-character-modal');
    const closeCreateCharacter = document.getElementById('close-create-character');
    const createCharacterForm = document.getElementById('create-character-form');
    const attackCreationList = document.getElementById('attack-creation-list');
    const addAttackBtn = document.getElementById('add-attack-btn');
    const assignOwnerField = document.getElementById('assign-owner-field');
    const createCharacterBtn = document.getElementById('create-character-btn');

    createCharacterBtn.addEventListener('click', () => {
      if (isDM()) {
        assignOwnerField.style.display = "block";
      } else {
        assignOwnerField.style.display = "none";
      }
      createCharacterModal.style.display = "block";
    });

    closeCreateCharacter.onclick = () => createCharacterModal.style.display = "none";

    addAttackBtn.addEventListener('click', () => {
      const row = document.createElement('div');
      row.className = 'attack-input-row';
      row.innerHTML = `
        <select class="attack-weapon-select" required>
          <option value="">--Select Weapon--</option>
          ${weapons.map(w => `<option value="${w.id}">${w.name}</option>`).join('')}
        </select>
        <input type="number" class="attack-custom-mod" value="0" style="width:50px;" title="Custom modifier" />
        <button type="button" class="remove-attack">X</button>
      `;
      attackCreationList.appendChild(row);
      const removeBtn = row.querySelector('.remove-attack');
      removeBtn.addEventListener('click', () => {
        row.remove();
      });
    });

    createCharacterForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const formData = new FormData(createCharacterForm);
      let owner = currentUser;
      if (isDM()) {
        owner = formData.get('owner') || owner;
        if (!users.includes(owner)) owner = "DM";
      }
      const newChar = {
        id: nextCharacterId++,
        owner: owner,
        name: formData.get('name'),
        class: formData.get('class'),
        level: parseInt(formData.get('level'),10),
        HP: parseInt(formData.get('HP'),10),
        AC: parseInt(formData.get('AC'),10),
        STR: parseInt(formData.get('STR'),10),
        DEX: parseInt(formData.get('DEX'),10),
        CON: parseInt(formData.get('CON'),10),
        INT: parseInt(formData.get('INT'),10),
        WIS: parseInt(formData.get('WIS'),10),
        CHA: parseInt(formData.get('CHA'),10),
        placed: false,
        attacks: []
      };

      const weaponSelects = createCharacterForm.querySelectorAll('.attack-weapon-select');
      const customMods = createCharacterForm.querySelectorAll('.attack-custom-mod');
      for (let i=0; i<weaponSelects.length; i++) {
        const wid = parseInt(weaponSelects[i].value,10);
        if (!isNaN(wid)) {
          const cmod = parseInt(customMods[i].value,10) || 0;
          newChar.attacks.push({weaponId:wid, customMod:cmod});
        }
      }

      characters.push(newChar);
      createCharacterModal.style.display = "none";
      createCharacterForm.reset();
      attackCreationList.innerHTML = '';
      renderCharacterList();
    });

    // Drag from lists
    let draggedCharId = null;
    let draggedMonsterId = null;

    function placeCharacterOnBoard(charId, row, col) {
      const ch = getCharacterById(charId);
      if (!ch) return;
      if (ch.placed) return;
      if (!canControlEntity({type:"character",id:charId})) return;

      const key = `${row},${col}`;
      if (entityTokens[key]) return;
      entityTokens[key] = {type:"character",id:charId};
      ch.placed = true;
      redrawBoard();
      renderCharacterList();
    }

    function placeMonsterOnBoard(monId, row, col) {
      const m = getMonsterById(monId);
      if (!m) return;
      if (!isDM()) return;
      const key = `${row},${col}`;
      if (entityTokens[key]) return;
      entityTokens[key] = {type:"monster",id:monId};
      redrawBoard();
      renderMonsterList();
    }

    const userSelectEl = document.getElementById('user-select');
    userSelectEl.addEventListener('change', (e) => {
      currentUser = e.target.value;
      renderCharacterList();
      renderMonsterList();
      renderLog();
    });

    // Render character and monster lists
    const characterListEntries = document.getElementById('character-list-entries');
    const monsterList = document.getElementById('monster-list');
    const monsterFilter = document.getElementById('monster-filter');
    const monsterListEntries = document.getElementById('monster-list-entries');

    function renderCharacterList() {
      characterListEntries.innerHTML = '';
      let visibleChars = characters.filter(ch => isDM() || ch.owner === currentUser);
      for (let ch of visibleChars) {
        const div = document.createElement('div');
        div.className = 'character-list-item';

        const canPlace = !ch.placed && canControlEntity({type:"character",id:ch.id});

        const dragIcon = document.createElement('span');
        dragIcon.textContent = '⚔';
        dragIcon.className = 'drag-icon';
        dragIcon.setAttribute('draggable', canPlace ? 'true' : 'false');
        if (canPlace) {
          dragIcon.addEventListener('dragstart', (ev) => {
            draggedCharId = ch.id;
            draggedMonsterId = null;
          });
          dragIcon.addEventListener('dragend', (ev) => {
            draggedCharId = null;
          });
        }

        div.appendChild(dragIcon);

        let textNode = document.createTextNode(`${ch.name} (Owner: ${ch.owner})`);
        div.appendChild(textNode);

        let openBtn = document.createElement('button');
        openBtn.textContent = 'Open Sheet';
        openBtn.disabled = !canControlEntity({type:"character", id:ch.id});
        openBtn.addEventListener('click', () => {
          if (canControlEntity({type:"character", id:ch.id})) {
            openCharacterSheet(ch);
          }
        });

        div.appendChild(openBtn);
        characterListEntries.appendChild(div);
      }
    }

    function renderMonsterList() {
      if (isDM()) {
        monsterList.style.display = "block";
      } else {
        monsterList.style.display = "none";
        return;
      }

      monsterListEntries.innerHTML = '';
      const filter = monsterFilter.value;
      let filtered = monsters;
      if (filter) {
        filtered = monsters.filter(m => m.habitats.includes(filter));
      }

      for (let m of filtered) {
        const div = document.createElement('div');
        div.className = 'monster-list-item';

        const canPlace = true;

        const dragIcon = document.createElement('span');
        dragIcon.textContent = '⚔';
        dragIcon.className = 'drag-icon';
        dragIcon.setAttribute('draggable', canPlace ? 'true' : 'false');
        if (canPlace) {
          dragIcon.addEventListener('dragstart', (ev) => {
            draggedMonsterId = m.id;
            draggedCharId = null;
          });
          dragIcon.addEventListener('dragend', (ev) => {
            draggedMonsterId = null;
          });
        }

        div.appendChild(dragIcon);

        let textNode = document.createTextNode(`${m.name}`);
        div.appendChild(textNode);

        let openBtn = document.createElement('button');
        openBtn.textContent = 'View Stats';
        openBtn.addEventListener('click', () => {
          if (isDM()) {
            openMonsterSheet(m);
          }
        });

        div.appendChild(openBtn);
        monsterListEntries.appendChild(div);
      }
    }

    monsterFilter.addEventListener('change', renderMonsterList);

    // Initial
    renderCharacterList();
    renderMonsterList();
    renderLog();


  </script>
</body>
</html>
